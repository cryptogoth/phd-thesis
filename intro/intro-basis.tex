\section{Quantum Gates and Circuit Bases}
\label{sec:intro-basis}

To compile, or implement, arbitrary quantum algorithms, we must construct circuits
out of gates from a universal set, which we call a \emph{circuit basis},
or just \emph{basis}.
This should not be confused with a basis for a vector space.
Therefore, we will now review quantum gates and how to combine them into
circuits. This procedure is known as quantum compiling, but we will not
delve into its details until we need them in Chapter \ref{chap:qcompile}.

A quantum gate on $n$-qubits is a $2^n \times 2^n$ unitary matrix
(an element of $U(2^n)$). We can consider this the overall circuit width.
Often, we find it useful to neglect a
global phase, since these cannot be measured in quantum mechanics.
However, a global
phase on a particular system $S$ may result in a measurable relative phase
in a large system $S'$ of which $S$ is a subsystem. Therefore, for our
purposes we will only distinguish between $U(2^n)$ and
$SU(2^n)$ in the few cases where it matters for
quantum compiling. The distinction between a quantum circuit
and a quantum gate is relative; often we consider a quantum gate as a
fundamental primitive of our physical technology, and a circuit as a
composite of these gates corresponding to a quantum algorithm.

In Section \ref{subsec:pauli} we
will review the Pauli single-qubit gates and their corresponding group.
In Section \ref{subsec:clifford} we will introduce the Clifford group.
In Section \ref{subsec:controlled} we will introduce controlled operations
and the Toffoli gate.
In Section \ref{subsec:qcompile-single} we will discuss \emph{single-qubit compiling}
and how a
general single-qubit gate can be compiled into rotations about Bloch sphere axes.
In Section \ref{subsec:distance} we will present distance metrics to
measure the quality of our single-qubit (and later multi-qubit) approximations.
In Section \ref{subsec:qcompile-bases} we will finally
define what it means for a gate set to be universal.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Pauli Group}
\label{subsec:pauli}

We review here the Pauli group on one qubit, $\mathcal{P}_1 = \{I, X, Y, Z\}$.
These last three represent
rotations of $\pi$ on the Bloch sphere about the $x$-axis, $y$-axis, and $z$-axis,
using the homomorphism between $SU(2)$ and $SO(3)$. The $2\times 2$ identity matrix
is denoted $I$. The group $\mathcal{P}_1$ also serves as a complex vector
basis for generating elements of $U(2)$.

\begin{IEEEeqnarray}{rcrclCrcrcl}
X & = & \sigma_x & = &
 \left[
  \begin{array}{cc}
    0 & 1 \\
    1 & 0 \\
  \end{array} \right]
& \qquad &
Y & = & \sigma_y & = &
 \left[
  \begin{array}{cc}
    0 & i \\
   -i & 0 \\
  \end{array} \right]
\\
Z & = & \sigma_z & = &
 \left[
  \begin{array}{cc}
    1 & 0 \\
    0 & -1 \\
  \end{array} \right]
& \qquad &
I & = & \sigma_0 & = &
 \left[
  \begin{array}{cc}
    1 & 0 \\
    0 & 1 \\
  \end{array} \right]
\end{IEEEeqnarray}

We define the Pauli group $\mathcal{P}_n$ on $n$ qubits as the set of
all $n$-qubit operators which are tensor products of elements from
$\mathcal{P}_1$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The Clifford Group}
\label{subsec:clifford}

We define the normalizer of $\mathcal{P}_n$ as the
Clifford group $\mathcal{C}_n$ on $n$ qubits.

\begin{equation}
\mathcal{C}_n = \{ C \in U(2^n) | CPC^{\dagger} \in \mathcal{P}_n \quad \forall P \in \mathcal{P}_n \}
\end{equation}

Of particular interest to us is the two-qubit Clifford group $\mathcal{C}_2$,
which is generated by the following matrices:

\begin{equation}
\mathcal{C}_2 = \langle H, S, CNOT \rangle
\end{equation}

The first two Clifford generator matrices are single-qubit gates ($2 \times 2$ unitary matrices) and
their inclusion means they can be applied on either the first or the second
qubit.\footnote{Standard convention writes $H_i$ to mean $H$ on qubit $i$ and likewise for $S_i$.}
The matrix $H$ is known as the Hadamard gate, and it is a special case of the
general Walsh-Hadamard transform. It is its own adjoint: $H^{\dagger} = H$.
The matrix $S$ is known as the phase gate, and it can be considered the
``square root'' of the Pauli $Z$ gate (up to a phase): $S^2 = Z$.
Equivalently, it can be viewed as a $\pi/2$ rotation about the Bloch sphere
$z$-axis, and its adjoint $S^{\dagger}$ is the reverse rotation of $-\pi /2$.
These matrices are defined below.

\begin{equation}
H = \normtwo
 \left[
  \begin{array}{cc}
    1 & 1 \\
    1 & -1 \\
  \end{array} \right]
\qquad
S = 
 \left[
  \begin{array}{cc}
    1 & 0 \\
    0 & i \\
  \end{array} \right]
\qquad
S^{\dagger} = 
 \left[
  \begin{array}{cc}
    1 & 0 \\
    0 & -i \\
  \end{array} \right]
\end{equation}

The Hadamard matrix also has the special property that it changes between the
$X$ basis and the $Z$ basis, that is, the vector basis for single-qubit
states consisting of eigenstates of the Pauli $X$ and Pauli $Z$ gates,
respectively. In fact, using the identities $X = HZH$ and $S^2 = Z$, it
is easy to see why $X$ and $Z$ are often listed as generators of the
Clifford group as well.

The last Clifford generator matrix is a two-qubit gate (a $4 \times 4$ unitary matrix) which
also represents a \emph{controlled} operation. That is, based on the
$\ket{1}$ component of the \emph{control} qubit, it applies a single-qubit
gate (in this case, Pauli $X$) to the \emph{target} qubit.
In fact,
both CNOT and $X$ are also fundamental gates in classical reversible
logic as well, where $X$ is also the Boolean $NOT$ gate on classical bits.
That is why the gate is called CNOT, for ``controlled-NOT.'' Its inclusion
in the generating set for $\mathcal{C}_2$ means that it can be applied
in either direction: with control on qubit 1 and target on qubit 2 or
vice versa. CNOT is defined below.
%
\begin{equation}
CNOT = 
 \left[
  \begin{array}{cccc}
    1 & 0 & 0 & 0 \\
    0 & 1 & 0 & 0 \\
    0 & 0 & 0 & 1 \\
    0 & 0 & 1 & 0
  \end{array} \right]
\end{equation}
%
Likewise, the general Clifford group on $n$ qubits $\mathcal{C}_n$
can be generated from the same set
as $\mathcal{C}_2$, with gates understood to apply to any of the $n$ qubits.
With three CNOTs, we can implement the $SWAP$ gate which exchanges the
states of two qubits.
%
\begin{equation}
SWAP = 
 \left[
  \begin{array}{cccc}
    1 & 0 & 0 & 0 \\
    0 & 0 & 1 & 0 \\
    0 & 1 & 0 & 0 \\
    0 & 0 & 0 & 1
  \end{array} \right]
\end{equation}
%
The gate CNOT has historical importance in quantum computing partly
due to its use in many
early quantum gate decompositions and its ability to
be performed fault-tolerantly in many physical technologies. It will be our
primary two-qubit gate.
Along with arbitrary single-qubit gates, it is universal for quantum computation \cite{Barenco1995a}.
Therefore, we will give this basis a special name:
%
\begin{equation}
\mathcal{Q} = \{ U(2) \cup CNOT \}
\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Controlled Gates}
\label{subsec:controlled}

The principle of a controlled gate can be generalized to multiple
controls using the ``meta-operator'' notation from \cite{Kitaev2002}.
By $\Lambda^n(U)$, we mean an $(n+1)$-qubit gate ($2^{n+1} \times 2^{n+1}$
unitary matrix) with $n$ control qubits and a single-qubit target gate
$U \in U(2)$. An important multiply-controlled gate, which is universal
for classical reversible circuits, is the Toffoli gate, or controlled-controlled-$NOT$.

\begin{equation}
\text{Toffoli} = \Lambda^2(X) = 
 \left[
  \begin{array}{cccccccc}
    1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
    0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\
    0 & 0 & 0 & 0 & 0 & 0 & 1 & 0
  \end{array} \right]
\end{equation}

As seen above, multiply-controlled single-qubit gates $\Lambda^n(U)$ have a
special, sparser structure than general $n$-qubit gates in $U(2^n)$.
These play a special role in many multi-qubit decompositions, about which
we will say more in Chapter \ref{chap:qcompile}.

There is also a special case of a ``targetless'' controlled single-qubit
gate which simply rotates the $\ket{1}$ component of a single-qubit state.

\begin{equation}
\Lambda(e^{i\phi}) = 
 \left[
  \begin{array}{cc}
    1 & 0 \\
    0 & e^{i\phi} \\
  \end{array} \right]
\end{equation}

This gate is a key tool and simplification for single-qubit compiling.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Single-Qubit Compiling}
\label{subsec:qcompile-single}

A seemingly simpler task than general compiling is single-qubit compiling.
This will illustrate the basic principles of quantum compiling and the
structure that we will exploit later to choose an effective basis. Moreover,
it will reveal a general relationship between many of the single-qubit
gates that we have already introduced.

First, we review how to decompose a general $U \in U(2)$ into three single-qubit
rotations about the Bloch sphere $x$-axis and $z$-axis, the so-called
Euler angle decompositions \cite{Nielsen2000}. This gives rise to a factor of $3$
which commonly appears in resource calculations in the literature.

\begin{equation}
U = e^{i\delta}R_Z(\gamma)R_X(\beta)R_Z(\alpha)
\end{equation}

The gate $R_Z(\phi)$ represents a rotation about the Bloch sphere $z$-axis,
of which the Pauli $Z$ gate is a special case of a $\pi$ rotation. In fact,
it is the same as the controlled-phase gate we introduced in the previous section,
up to a global phase.

\begin{equation}
R_Z(\phi) =
\left[
  \begin{array}{cc}
    e^{-i\phi/2} & 0 \\
    0 & e^{i\phi/2} \\
  \end{array} \right]
=
e^{-i\phi / 2} \left[
  \begin{array}{cc}
    1 & 0 \\
    0 & e^{i\phi} \\
  \end{array} \right]
= e^{-i\phi / 2} \Lambda(e^{i\phi})
\end{equation}

We can now state the relationship between $S$ and $Z$, as well as introduce
an important new gate $T$ which is the square root of $S$ up to a phase. All three
are rotations about the Bloch $z$-axis by power-of-two fractions of $\pi$.

\begin{equation}
Z = R_Z(\pi) =
\left[
  \begin{array}{cc}
    1 & 0 \\
    0 & -1 \\
  \end{array} \right]
\qquad
S = R_Z(\tfrac{\pi}{2}) =
\left[
  \begin{array}{cc}
    1 & 0 \\
    0 & i \\
  \end{array} \right]
\qquad
T = R_Z(\tfrac{\pi}{4}) =
\left[
  \begin{array}{cc}
    1 & 0 \\
    0 & e^{i\pi / 4} \\
  \end{array} \right]
\end{equation}
%
Likewise, the gate $R_X(\phi)$ represents a rotation about the Bloch sphere $x$-axis,
of which the Pauli $X$ gate is a special case of a $\pi$ rotation.
%
\begin{equation}
R_X(\phi) =
\left[
  \begin{array}{cc}
    \cos \tfrac{\phi}{2} & -i \sin \tfrac{\phi}{2} \\
    -i \sin \tfrac{\phi}{2} & \cos \tfrac{\phi}{2} \\
  \end{array} \right]
\end{equation}

Similar decompositions can be given in terms of $R_X$ and $R_Y$, or in
terms of $R_Y$ and $R_Z$. Solving for the angles $\{ \alpha, \beta, \gamma, \delta \}$
involves writing four equations in four variables, which can be found in
the standard textbook \cite{Nielsen2000}. We will not say
more about their solution here, except that we can implement the
global phase shift $e^{i\delta}$ using the identities below, which are
adapted from \cite{Kitaev2002}.

\begin{eqnarray}
e^{i\delta} & = & R_Z(\phi)\cdot X \cdot R_Z(\phi) \cdot X \\
X & = & R_X(\pi) \\
Z & = & R_Z(\pi) \\
R_X(\phi) & = & H \cdot R_Z(\phi) \cdot H
\end{eqnarray}

It now seems that a reasonable basis for single-qubit compiling are
arbitrary $R_Z(\phi)$ and $R_X(\phi)$ rotations, along with $H$.
However, in practice our classical control can only implement
rotations with finite precision. How can we measure this, or any
other, precision arising from approximation?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Distance Metrics}
\label{subsec:distance}

Each gate from our basis is a unitary matrix of bounded dimension, and the action of an entire
$n$-qubit compiled circuit $\tilde{C}$
is also a $2^n \times 2^n$ unitary matrix. This matrix can be formed
by the product of $2^n \times 2^n$ matrices $G_i$ which are a tensor
product of gate matrices from our basis operating on individual qubits.
Our desired target matrix $C$ is itself
a matrix from $U(2^n)$, and therefore we will need a distance metric
that operates on matrices (specifically, the difference of matrices).

\begin{equation}
\tilde{C} = G_{D}G_{D-1}\cdots G_{2} G_{1}
\end{equation}

One distance metric used in theoretical literature
is the operator norm of a matrix $M$,
is defined as the maximum amount it scales the vector norm
of all unit-length vectors. This is sometimes also called the
infinity-norm, or supremum-norm (sup-norm).

\begin{equation}
\| M \|_{\infty} = \max_{\| \ket{v} \| = 1} \| M \ket{v} \|
\end{equation}

However, this is not an operational definition.
Moreover, we often wish to neglect a global phase in a unitary matrix,
which is not measurable in quantum physics. To measure phase-independent
distance between two unitary matrices, we can use the following
distance measure due to Fowler \cite{Fowler2011}.

\begin{equation}
dist(U, V) = \| U - V\| \equiv \sqrt{\frac{2^n - |tr(U^{\dag}V)|}{2^n}}
\end{equation}

Now can quantify the quality of our approximations through an
error $\epsilon$.

\begin{equation}
\| C - \tilde{C}\| = \| C -  G_D\cdots G_1 \| < \epsilon
\end{equation}

Often $\epsilon$ will be small, and we will upper bound it by some
power of $\frac{1}{2}$. Therefore, we define a
new parameter $\nu$ which is the number of bits needed to encode the exponent
of this increasingly small fraction.

\begin{equation}
\epsilon = \frac{1}{2^\nu} \qquad
\nu = \log(1/\epsilon)
\end{equation}

It is natural to suppose that compiling better approximations requires
more resources, and these resources are expressed as functions of
these
parameters, increasing with decreasing $\epsilon$ and increasing $\nu$.
In fact, often the efficiency and the
capabilities of a quantum
compiler depend on its basis. Therefore, we conclude this section by
discussing circuit bases.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Circuit Bases}
\label{subsec:qcompile-bases}

\begin{definition}{\textbf{Circuit basis.}}
A basis for a quantum circuit (family) is a universal set of
bounded-qubit gates (usually operating on no more than 3 qubits each).
We call a basis \emph{finite} if it contains a finite
number of gates; that is, it contains discrete gates and not an infinite
continuum of gates. We call a basis \emph{fixed} if its members are independent
of the number of qubits in the input circuit (its width).
\end{definition}

For fault-tolerant quantum computing, we are interested in compiling
circuits to a fixed, finite basis. What does it mean for a fixed, finite
basis to be universal for an infinite group like $SU(2^n)$?

\begin{definition}{\textbf{Universal approximation.}}
We call a fixed, finite set of gates $\mathcal{G}$ \emph{universal} for
a group $U(2^n)$ iff for every desired target $C \in U(2^n)$ and
desired error $\epsilon$, we can return a
sequence of gates $(g_1,g_2,\ldots,g_S)$ from $\mathcal{G}$ where

\begin{equation}
\| C - g_1 g_2 \cdots g_S \| \le \epsilon
\end{equation}

\end{definition}

This defines whether a gateset is a basis, or whether universal approximation
is even possible (non-constructively). We will see in
Chapter \ref{chap:qcompile} that
quantum compilers are concerned with constructive approaches to
\emph{efficiently} return such a compiled sequence $\tilde{C} = \prod g_i$.
Examples of efficiency metrics are the number of returned gates $S$ or
the running time of the quantum compiling algorithm (which itself is
primarily classical).

What gatesets are known to be fixed, finite, and universal, and therefore
suitable bases for quantum compilation? We state without proof that
the following basis satisfies these properties, and we will use it later as
our circuit basis in Chapters \ref{chap:factor-polylog} and
\ref{chap:factor-sublog}.

\begin{equation}
\mathcal{G} = \{X, Z, H, \text{Toffoli}, \text{CNOT}\}
\end{equation}

It is important to note that the only non-Clifford gate in the above basis
is Toffoli.
The Clifford group $\mathcal{C}_n$ by itself is \emph{not}
universal.
In fact, it is provable
that \emph{any} universal gateset must possess at least one
non-Clifford gate \cite{Zeng2011}.
Two popular choices for the non-Clifford gate in a basis are the $T = R_Z(\pi/4)$
gate and the $\text{Toffoli} = \Lambda^2(X)$ gate. Since these are not ``natively''
supported (non-transversal) in many codes, they must often be implemented
probabilistically using only Clifford operations and $MeasureZ$, usually
by way of a so-called ``magic'' state.
Therefore, many quantum compilers
use the Clifford+$T$ basis ($\mathcal{C}_2 \cup \{ T \}$)
or the Clifford+Toffoli basis ($\mathcal{C}_2 \cup \{ \text{Toffoli} \}$),
and measure
the non-Clifford gate as the most expensive resource. It is an area of
active research
whether $T$ or Toffoli is more efficient to implement
\cite{Jones2013a,Eastin2012}.

For single-qubit compilation, the $\{H,T, T^{\dagger}\}$ gateset is universal and
plays an important role in the literature. Other compilers may add
the Clifford gates $S$ and $S^{\dagger}$ to the bases above,
but this does not change their universality nor its asymptotic efficiency for
compiling. From our discussion in this section
on quantum gates and circuit bases, we are now prepared to add some additional
circuit constraints to form quantum architectures.