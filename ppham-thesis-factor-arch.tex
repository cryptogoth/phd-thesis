\section{Background}
\label{sec:fpl-bg}

Quantum architecture is the design of physical qubit layouts
and their allowed interactions to execute
quantum algorithms efficiently in time, space, and other
resources.
In this paper, we focus on designing a realistic nearest-neighbor circuit for running
Shor's factoring algorithm on two-dimensional
architectural models of a physical quantum device with nearest-neighbor
interactions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Architectural Models and Circuit Resources}
\label{subsec:models}

Following Van Meter and Itoh \cite{VanMeter2005},
we distinguish between a model and an architectural implementation as follows.
A \emph{model} is a set of constraints and rules for the placement and
interaction of qubits.
An \emph{architecture} (or interchangeably, an \emph{implementation} 
or a \emph{circuit}) is a particular
spatial layout of qubits (as a graph of vertices) and allowed interactions (edges between the vertices),
following the constraints of a given model. In this section, we describe
several models which try to incorporate resources of physical interest from
experimental work. We also introduce a new model,
\textsc{2D CCNTCM}, which we will use to analyze our current circuit.

The most general model is called Abstract Concurrent (\textsc{AC})
and allows arbitrary, long-range interactions between any qubits and concurrent
operation of quantum gates.
This corresponds to a complete graph with an edge between every pair of nodes.
It is the model assumed in most quantum algorithms.

A more specialized model restricts interactions to nearest-neighbor, two-qubit,
concurrent gates (\textsc{NTC}) in a regular one-dimensional chain (1D NTC),
which is sometimes called linear nearest-neighbor (\textsc{LNN}).
This corresponds to a line graph. This is a more realistic model than
\textsc{AC}, but correspondingly, circuits in this model may incur greater
resource overheads.

To relieve movement congestion,
we can consider a two-dimensional regular grid
(2D NTC), where each
qubit has four planar neighbors, and 
there is an extra degree of freedom over the 1D model
in which to move data.
In this paper, we extend the \textsc{2D NTC} model in three ways.
The first two extensions are described in Section \ref{subsec:2dccntc},
and the third extension is described in Section \ref{subsec:2dccntcm}.

\subsection{\textsc{2D CCNTC}: Two-Dimensional Nearest-Neighbor Two-Qubit Concurrent Gates with Classical Controller}
\label{subsec:2dccntc}

The first extension allows arbitrary planar graphs
with bounded degree, rather than a regular square lattice.
Namely, we assume qubits lie in a plane and edges are not allowed to intersect.
All qubits are accessible from above
or below by control and measurement apparatus.
Whereas 2D NTC conventionally assumes each qubit
has four neighbors, we consider up to six neighbors in a roughly hexagonal
layout. The edge length in this model is no more than twice the edge length
in a regular 2D NTC lattice. The second extension is the realistic assumption
that classical control (CC) can
access every qubit in parallel, and we do not count these classical
resources in our implementation since they are polynomially bounded. The
classical controllers
correspond to fast digital computers which are
available in actual experiments and are necessary for constant-depth
communication in the next section.

We call an AC or NTC model augmented by these two extensions
\textsc{CCAC} and \textsc{CCNTC}, respectively. Before we describe the
third extension, let us formalize our model for \textsc{2D CCNTC}, with definitions that are (asymptotically) equivalent to those in 
\cite{Rosenbaum2012}.

\begin{definition}
A 2D CCNTC architecture consists of

\begin{itemize}
\item a quantum computer $QC$ which is represented by a planar graph $(V,E)$. A
node $v \in V$ represents a qubit which is acted upon in a circuit, and an
undirected edge $(u,v) \in E$ represents 
an allowed two-qubit interaction between qubits $u,v \in V$. Each node has
degree at most $6$.
\item a universal gate set $\mathcal{G} = \{X, Z, H, T, T^{\dagger}, CNOT, MeasureZ\}$.

\item a deterministic machine (classical controller) $CC$ that applies a sequence
of concurrent gates in each of $D$ timesteps.
\item In timestep $i$, $CC$ applies a set of
gates $G_i = \{g_{i,j} \in \mathcal{G} \}$.
Each $g_{i,j}$ operates in one of the following two ways:
\begin{enumerate}
\item It is a single-qubit gate from $\mathcal{G}$ acting on a single qubit $v_{i,j} \in V$
\item
It is the gate CNOT from $\mathcal{G}$ acting on two qubits $v^{(1)}_{i,j}, v^{(2)}_{i,j} \in V$ where
$(v^{(1)}_{i,j}, v^{(2)}_{i,j}) \in E$
\end{enumerate}
All the $g_{i,j}$ can only operate on
disjoint qubits for a given timestep $i$. We define the support of $G_i$
as $V_i$, the set of all qubits acted upon during timestep $i$.

\begin{equation}
V_i = \bigcup_{j: g_{i,j} \in G_i} v_{i,j} \cup v^{(1)}_{i,j} \cup v^{(2)}_{i,j}
\end{equation}

\end{itemize}
\end{definition}

We can then define the three conventional circuit resources in this model.

\begin{description}
\item[circuit depth ($D$):] the number of concurrent timesteps.
\item[circuit size ($S$):] the total number of non-identity gates applied
from $\mathcal{G}$, equal to $\sum_{i=1}^D |G_i|$.
\item[circuit width ($W$):] the total number of qubits operated upon by
any gate, including inputs, outputs, and ancillae. It is equal to $| \bigcup_{i=1}^D V_i|$.
\end{description}

We observe that the following relationship holds between the circuit resources.
The circuit size is bounded above by
the product of circuit depth and circuit width, since in the worst case,
every qubit is acted upon by a gate for every timestep of a circuit.
The circuit depth is also bounded above by the size, since in the worst case,
every gate is executed serially without any concurrency.

\begin{equation}
D \le S \le D\cdot W
\label{eqn:depth-width}
\end{equation}

The set $\mathcal{G}$ includes measurement in the $Z$ basis, which is
actually not a unitary operation but which may be slower than unitary
operations in actual practice \cite{DiVincenzo2007}.
Therefore we count it in our resource
estimates.
All other gates
in $\mathcal{G}$ form a universal set of unitary
gates \cite{Kitaev2002}.
 In this paper we
will treat the operations in $\mathcal{G}$ as \emph{elementary gates}.
We can also define a Bell basis measurement using operations
from $\mathcal{G}$. A circuit performing this measurement is shown
in Figure \ref{fig:bell-measure} and has depth $4$,
size $4$, and width $2$.

\begin{figure*}[tb!]
\begin{center}
\begin{displaymath}
\begin{array}{ccc}
\Qcircuit @C=1em @R=1em {
& \qw & \multimeasureD{1}{\mbox{Bell}} & \cw & \rstick{j} \\
& \qw & \ghost{\mbox{Bell}}            & \cw & \rstick{k}
}
& \qquad \equiv \qquad &
\Qcircuit @C=1em @R=1em {
& \qw & \ctrl{1} & \qw & \gate{H} & \qw & \meter & \cw & \rstick{j} \\
& \qw & \targfix & \qw & \qw      & \qw & \meter & \cw & \rstick{k}
}
\end{array}
\end{displaymath}
\centerline{}
\fcaption{A circuit for measurement in the Bell state basis.}
\label{fig:bell-measure}
\end{center}\end{figure*}

The third extension to our model, and the most significant, is to consider
multiple disconnected planar graphs, each of which is a 2D CCNTC
architecture. This is described in more detail in the next section.

\subsection{\textsc{2D CCNTCM}: Two-Dimensional Nearest-Neighbor Two-Qubit Concurrent Gates with Classical Controller and Modules}
\label{subsec:2dccntcm}

A single, contiguous
2D lattice which contains an entire quantum architecture which may be prohibitively large to manufacture. In practice,
scalable experiments will probably use many
smaller quantum computers which communicate by means of shared
entanglement \cite{Monroe2012}.
We call these individual machines \emph{modules}, each of
which is a self-contained \textsc{2D CCNTC} lattice. This should not be
confused with the word ``modular'' as in ``modular arithmetic'' or as
referring to the modulus $m$ which we are trying to factor.

We treat these modules
and teleportations between them as nodes and edges, respectively,
in a higher-level planar graph. The teleportations each transmit one qubit
from one module to another, from any location within the source module
to any location within the destination module, making use of the
omnipresent classical controller. The modules can be arbitrarily far
apart physically, but they have bounded-degree connectivity with other
modules, and their edges are planar (they cannot intersect).

A single module can be part of multiple teleportation operations in a single timestep, as long as they involve disjoint qubits within the module.
We justify this assumption in that it is
possible to establish entanglement between multiple
quantum computers
in parallel. We call this new model \textsc{2D CCNTCM},
and we argue that is captures the essential aspects of 2D architectures
without being overly sensitive to the exact geometry of the lattices involved.
An graphic depiction of three modules in \textsc{2D CCNTCM} is shown in
Figure \ref{fig:modules}. Each module contains within it a
\textsc{2D CCNTC} lattice. We can equivalently consider the omnipresent,
single
classical controller as a collection of multiple classical controllers, one
for each module or teleportation operation, which can inter-communicate
classically and share a clock.

\begin{figure}[btp!]
\begin{center}
\includegraphics[width=4in]{./modules.pdf}
\end{center}
\fcaption{Three modules in the \textsc{2D CCNTCM} model}
\label{fig:modules}
\end{figure}

\begin{definition}
A \textsc{2D CCNTCM} architecture consists of

\begin{itemize}
\item a quantum computer $\overline{QC}$ which is represented by a planar graph $(\overline{V},\overline{E})$. A
node $\overline{v} \in \overline{V}$ represents a module, or a graph $(V,E)$
from a \textsc{2D CCNTC} architecture defined previously. It can have
unbounded degree.
An
undirected edge $(\overline{u},\overline{v}) \in \overline{E}$ represents an
allowed teleportation from any qubit in module $\overline{u}$ to
another qubit in module $\overline{v}$.
\item All modules are restricted to be linear in the number of their qubits:
$|V| = \Theta(n)$ for all $(V,E) \in \overline{V}$.
\item a universal gate set $\mathcal{G} = \{X, Z, H, T, T^{\dagger}, CNOT,
MeasureZ\}$
for the qubits \emph{within the same} modules which is the same as for \textsc{2D CCNTC},
and an additional operation $Teleport$ which only operates on qubits
\emph{in
different} modules.
\item a deterministic machine (classical controller) $\overline{CC}$ that applies a sequence
of concurrent gates in each of $D+\overline{D}$ timesteps.
This can be a separate classical controller
for every pair of modules.
\item In timestep $i$, $\overline{CC}$ applies
gates $G_i = \{g_{i,j} : g_{i,j} \in \mathcal{G} \lor g_{i,j} = Teleport \}$.
That is, there are two kinds of timesteps with respect to the kinds of gates
which operate within them.
\begin{enumerate}
\item In the first kind, gates are exclusively from $\mathcal{G}$, and
they operate within modules as described
for \textsc{2D CCNTC} above. We say there are $D$ such timesteps.
\item In the second kind, gates are exclusively $Teleport$ gates between two qubits $v^{(1)}_{i,j} \in \overline{v}_1$ and
$v^{(2)}_{i,j} \in \overline{v}_2$ for
(possibly non-distinct) modules $\overline{v}_1, \overline{v}_2 \in \overline{V}$.
Again, all such qubits much be distinct within a timestep.
We say there are $\overline{D}$ such timesteps.
\end{enumerate}

Again, we define the support of $G_i$
as $V_i$, the set of all qubits acted upon by any $g_{i.j}$, which
includes all the modules.
\begin{equation}
V_i = \bigcup_{j: g_{i,j} \in G_i} v_{i,j} \cup v^{(1)}_{i,j} \cup v^{(2)}_{i,j} 
\end{equation}

\end{itemize}
\end{definition}

We measure the efficiency of a circuit in this new module using not just
the three conventional circuit resources, but with three novel resources
based on modules.

\begin{description}

%, depicted in Figure \ref{fig:resources}:
\item[module depth ($\overline{D}$):] the depth of consecutive teleportations between modules.
\item[module size ($\overline{S}$):] the number of total qubits teleported between any two modules over all timesteps.
\item[module width ($\overline{W}$):] the number of modules whose qubits are
acted upon during any timestep.

\end{description}

%We can make an observation analogous to Equation \ref{eqn:depth-width} but
%for modules in Equation \ref{eqn:module-depth-width}.

%\begin{equation}
%\overline{D} \le \overline{S} \le \overline{D}\cdot \overline{W}
%\label{eqn:module-depth-width}
%\end{equation}

We note the following relationship between circuit width and
module width.

\begin{equation}
W = O(n\overline{W})
\label{eqn:module-width}
\end{equation}

This restriction imposes some locality on our model by constraining it to
nearest-neighbor gates within a linear-sized group of qubits, but allowing
it long-range teleportation to circumvent onerous geometric constraints.
Using the constant-depth communication in Section \ref{sec:cdc}, and for
the specific case of factoring, we
can simulate arbitrary connectivity between modules with only a polynomial
increase in the module size and a constant increase in module depth.

\subsection{Circuit Resource Comparisons}

Counting gates from $\mathcal{G}$ as having unit size and unit depth
is
an overestimate compared to the model in \cite{Kutin2006}, in which a
two-qubit gate has unit size and unit depth and
absorbs the depth and size of any adjacent single-qubit gates. We intend
for this more pessimistic estimate to reflect the practical difficulties
in compiling these gates using a non-Clifford gate in a fault-tolerant way,
such as the $T$ gate or the Toffoli gate
\cite{Fowler2011}.
%However, these difficulties may be mitigated by using
%Toffoli gates directly, which can be fault-tolerantly implemented using
%magic-state distillation according to recent works \cite{Eastin2012,Jones2013a}.

In both our resource counting method and that of \cite{Fowler2004,Kutin2006}, multiple gates acting on disjoint qubits
can occur in parallel during the same timestep. For each building block,
from modular addition to modular multiplication and finally to modular
exponentiation, we provide closed form equations upper-bounding the required circuit
resources as a function of $n$, the size of the modulus $m$ to be factored.
We will use the
term \emph{numerical upper bound} to distinguish these formulae from asymptotic
upper bounds.

It is possible to reduce the numerical constants with more detailed analysis,
which would be important for any physical implementation.
However, we have chosen instead to simplify the number of terms in the formulae
for the current work. We do not intend for these upper bounds to represent
the optimal or final work in this area.

The modular adder in Section \ref{sec:csa-mod-add} and its carry-save
subcomponents only occur within a single module, so we only give their
circuit resources in terms of circuit depth, circuit size, and circuit width. 
For the modular multiplier in
Section \ref{sec:csa-mod-mult} and the modular exponentiator in
Section \ref{sec:modexp}, we also give circuit resources in
terms of module depth, module size, and module width.