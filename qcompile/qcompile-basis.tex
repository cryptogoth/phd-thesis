\section{Quantum Gates and Circuit Bases}
\label{sec:qcompile-basis}

To compile, or implement, arbitrary quantum algorithms, we must construct circuits
out of gates from a universal set, which we call a \emph{circuit basis},
or just \emph{basis}.
This should not be confused with a basis for a vector space.
Therefore, we will now review quantum gates, how to combine them into
circuits, and what it means to be universal.

A quantum gate on $n$-qubits is a $2^n \times 2^n$ unitary matrix
(an element of $U(2^n)$). We can consider this the overall circuit width.
Often, we find it useful to neglect a
global phase, since these cannot be measured in quantum mechanics.
However, a global
phase on a particular system $S$ may result in a measurable relative phase
in a large system $S'$ of which $S$ is a subsystem. Therefore, for our
purposes we will only distinguish between $U(2^n)$ and
$SU(2^n) = U(2^n) / U(1)$ in the few cases where it matters for
quantum compiling. As in the discussion of classical circuits from
Section \ref{sec:fsl-circuits}, the distinction between a quantum circuit
and a quantum gate is relative; often we consider a quantum gate as a
fundamental primitive of our physical technology, and a circuit as a
composite of these gates corresponding to a quantum algorithm.

In Section \ref{subsec:pauli} we
will review the Pauli single-qubit gates and their corresponding group.
In Section \ref{subsec:clifford} we will introduce the Clifford group.
In Section \ref{subsec:controlled} we will introduce controlled operations
and the Toffoli gate.
In Section \ref{subsec:qcompile-single} we will discuss \emph{single-qubit compiling}
and how a
general single-qubit gate can be compiled into rotations about Bloch sphere axes.
In Section \ref{subsec:distance} we will present distance metrics to
measure the quality of our single-qubit (and later multi-qubit) approximations.
In Section \ref{subsec:qcompile-bases} we will finally
define what it means to be a universal gate set, or a circuit basis.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Pauli Group}
\label{subsec:pauli}

We review here the Pauli group on one qubit, $\mathcal{P}_1 = \{I, X, Y, Z\}$.
These last three represent
rotations of $\pi$ on Bloch sphere about the $x$-axis, $y$-axis, and $z$-axis,
using the homomorphism between $SU(2)$ and $SO(3)$, as well as the
identity matrix $I$. The group $\mathcal{P}_1$ also serves as a complex vector
basis for generating elements of $U(2)$.

\begin{equation}
X = \sigma_x
 \left[
  \begin{array}{cc}
    0 & 1 \\
    1 & 0 \\
  \end{array} \right]
\qquad
Y = \sigma_z =
 \left[
  \begin{array}{cc}
    0 & i \\
   -i & 0 \\
  \end{array} \right]
\qquad
Z = \sigma_z =
 \left[
  \begin{array}{cc}
    1 & 0 \\
    0 & -1 \\
  \end{array} \right]
\qquad
I = \sigma_0 =
 \left[
  \begin{array}{cc}
    1 & 0 \\
    0 & 1 \\
  \end{array} \right]
\end{equation}

We define the Pauli group $\mathcal{P}_n$ on $n$ qubits as the set of
all $n$-qubit operators which are tensor products of elements from
$\mathcal{P}_1$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The Clifford Group}
\label{subsec:clifford}

We define the normalizer of $\mathcal{P}_n$ as the
Clifford group $\mathcal{C}_n$ on $n$ qubits.

\begin{equation}
\mathcal{C}_n = \{ C \in U(n) | CPC^{\dagger} \in \mathcal{P}_n \quad \forall P \in \mathcal{P}_n \}
\end{equation}

Of particular interest to us is the two-qubit Clifford group $\mathcal{C}_2$,
which is generated by the following matrices (and their adjoints):

\begin{equation}
\mathcal{C}_2 = \langle H, S, CNOT \rangle
\end{equation}

The first two Clifford generator matrices are single-qubit gates ($2 \times 2$ unitary matrices) and
their inclusion means they can be applied on either the first or the second
qubit.
The matrix $H$ is known as the Hadamard gate, and it is a special case of the
general Walsh-Hadamard transform. It is its own adjoint: $H^{\dagger} = H$.
The matrix $S$ is known as the phase gate, and it can be considered the
``square root'' of the Pauli $Z$ gate (up to a phase): $S^2 = Z$.
Equivalently, it can be viewed as a $\pi/2$ rotation about the Bloch sphere
$z$-axis, and its adjoint $S^{\dagger}$ is the reverse rotation of $-\pi /2$.
These matrices are defined below.

\begin{displaymath}
H = \normtwo
 \left[
  \begin{array}{cc}
    1 & 1 \\
    1 & -1 \\
  \end{array} \right]
\qquad
S = 
 \left[
  \begin{array}{cc}
    1 & 0 \\
    0 & i \\
  \end{array} \right]
\qquad
S^{\dagger} = 
 \left[
  \begin{array}{cc}
    1 & 0 \\
    0 & -i \\
  \end{array} \right]
\end{displaymath}

The Hadamard matrix also has the special property that it changes between the
$X$ basis and the $Z$ basis, that is, the vector basis for single-qubit
states consisting of eigenstates of the Pauli $X$ and Pauli $Z$ gates,
respectively. In fact, using the identities $X = HZH$ and $S^2 = Z$, it
is easy to see why $X$ and $Z$ are often listed as generators of the
Clifford group as well.

The last Clifford generator matrix is a two-qubit gate (a $4 \times 4$ unitary matrix) which
also represents a \emph{controlled} operation. That is, based on the
$\ket{1}$ component of the \emph{control} qubit, it applies a single-qubit
gate (in this case, Pauli $X$) to the \emph{target} qubit.
In fact,
both $CNOT$ and $X$ are also fundamental gates in classical reversible
logic as well, where $X$ is also the Boolean $NOT$ gate on classical bits.
That is why the gate is called $CNOT$, for ``controlled-NOT.'' Its inclusion
in the generating set for $\mathcal{C}_2$ means that it can be applied
in either direction: with control on qubit 1 and target on qubit 2 or
vice versa. $CNOT$ is defined below.

\begin{displaymath}
CNOT = 
 \left[
  \begin{array}{cccc}
    1 & 0 & 0 & 0 \\
    0 & 1 & 0 & 0 \\
    0 & 0 & 0 & 1 \\
    0 & 0 & 1 & 0
  \end{array} \right]
\end{displaymath}

Likewise, general $\mathcal{C}_n$ can be generated from the same set
as $\mathcal{C}_2$, with gates understood to apply to any of the $n$ qubits.
The gate $CNOT$ has historical importance in quantum computing partly
due to its use in many
early quantum gate decompositions and its ability to
be performed fault-tolerantly in many physical technologies. It will be our
primary two-qubit gate.
Along with arbitrary single-qubit gates, it is universal for quantum computation \cite{Barenco1995a}.
Therefore, we will give it a special name:

\begin{equation}
\mathcal{Q} = \{ U(2) \cup CNOT \}
\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Controlled Gates}
\label{subsec:controlled}

The principle of a controlled gate can be generalized to multiple
controls using the ``meta-operator'' notation from \cite{Kitaev2002}.
By $\Lambda^n(U)$, we mean an $(n+1)$-qubit gate ($2^{n+1} \times 2^{n+1}$
unitary matrix) with $n$ control qubits and a single-qubit target gate
$U \in U(2)$. An important multiply-controlled gate, which is universal
for classical reversible circuits, is the Toffoli gate, or controlled-controlled-$NOT$.

\begin{equation}
Toffoli = \Lambda^2(X) = 
 \left[
  \begin{array}{cccccccc}
    1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
    0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\
    0 & 0 & 0 & 0 & 0 & 0 & 1 & 0
  \end{array} \right]
\end{equation}

As seen above, multiply-controlled single-qubit gates $\Lambda^n(U)$ have a
special, sparser structure than general $n$-qubit gates in $U(2^n)$. At the
same time, it is not known how to implement them generally on physical systems
which have nearest-neighbor constraints. Combining these two facts, we can
use a common heuristic for the general task of quantum compiling:
(a) first reducing them to $\Lambda^{n-1}(U)$ gates, and then (b) compiling
the $\Lambda^{n-1}(U)$ gates to $\mathcal{Q}$.
Task (a) is discussed in Section \ref{subsec:qcompile-multi}.
We will not discuss task (b) any further except for the special case of
singly-controlled gates of the form $\Lambda(U)$ below. We refer the
interested reader to Rosenbaum \cite{Rosenbaum2012} who has shown
optimal circuits for $\Lambda^n(U)$ gates over the basis $\mathcal{Q}$
on \textsf{CCNTC}.

There is also a special case of a ``targetless'' controlled single-qubit
gate which simply rotates the $\ket{1}$ component of a single-qubit state.

\begin{equation}
\Lambda(e^{i\phi}) = 
 \left[
  \begin{array}{cc}
    1 & 0 \\
    0 & e^{i\phi} \\
  \end{array} \right]
\end{equation}

This gate is a key tool and simplification for single-qubit compiling.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Single-Qubit Compiling}
\label{subsec:qcompile-single}

A seemingly simpler task than general compiling is single-qubit compiling.
This will illustrate the basic principles of quantum compiling and the
structure that we will exploit later to choose an effective basis. Moreover,
it will reveal a general relationship between many of the single-qubit
gates that we have already introduced.

First, we review how to decompose a general $U \in U(2)$ into three single-qubit
rotations about the Bloch sphere $x$-axis and $z$-axis, the so-called
Euler angle decompositions \cite{Nielsen2000}. This gives rise to a factor of $3$
which commonly appears in resource calculations in the literature.

\begin{equation*}
U = e^{i\delta}R_Z(\gamma)R_X(\beta)R_Z(\alpha)
\end{equation*}

The gate $R_Z(\phi)$ represents a rotation about the Bloch sphere $z$-axis,
of which the Pauli $Z$ gate is a special case of a $\pi$ rotation. In fact,
it is the same as the controlled-phase gate we introduced in the previous section.

\begin{equation}
R_Z(\phi) = \Lambda(e^{i\phi}) =
\left[
  \begin{array}{cc}
    1 & 0 \\
    0 & e^{i\phi} \\
  \end{array} \right]
=
\left[
  \begin{array}{cc}
    e^{-i\phi/2} & 0 \\
    0 & e^{i\phi/2} \\
  \end{array} \right]
\end{equation}

We can now state the relationship between $S$ and $Z$, as well as introduce
an important new gate $T$ which is the square root of $S$ up to a phase. All three
are rotations about the Bloch $z$-axis by power-of-two fractions of $\pi$.

\begin{equation}
Z = R_Z(\pi) =
\left[
  \begin{array}{cc}
    1 & 0 \\
    0 & -1 \\
  \end{array} \right]
\qquad
S = R_Z(\pi/2) =
\left[
  \begin{array}{cc}
    1 & 0 \\
    0 & i \\
  \end{array} \right]
\qquad
T = R_Z(\pi/4) =
\left[
  \begin{array}{cc}
    1 & 0 \\
    0 & e^{i\pi / 4} \\
  \end{array} \right]
\end{equation}

Likewise, the gate $R_X(\phi)$ represents a rotation about the Bloch sphere $x$-axis,
of which the Pauli $X$ gate is a special case of a $\pi$ rotation.

\begin{equation}
R_X(\phi) =
\left[
  \begin{array}{cc}
    \cos \phi & -i \sin \phi \\
    -i \sin \phi & \cos \phi \\
  \end{array} \right]
\end{equation}

Similar decompositions can be given in terms of $R_X$ and $R_Y$, or in
terms of $R_Y$ and $R_Z$. Solving for the angles $\{ \alpha, \beta, \gamma, \delta \}$
involves writing four equations in four variables, which can be found in
the standard textbook \cite{Nielsen2000}. We will not say
more about their solution here, except that we can implement the
global phase shift $e^{i\delta}$ using the identities below, which are
adapted from \cite{Kitaev2002}.

\begin{eqnarray}
e^{i\delta} & = & R_Z(\phi)\cdot X \cdot R_Z(\phi) \cdot X \\
X & = & R_X(\pi) \\
Z & = & R_Z(\pi) \\
R_X(\phi) & = & H \cdot R_Z(\phi) \cdot H
\end{eqnarray}

It now seems that a reasonable basis for single-qubit compiling are
arbitrary $R_Z(\phi)$ and $R_X(\phi)$ rotations, along with $H$.
However, in practice our classical control can only implement
rotations with finite precision. How can we measure this, or any
other, precision arising from approximation?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Distance Metrics}
\label{subsec:distance}

Each gate from our basis is a unitary matrix of bounded dimension, and the action of an entire
$n$-qubit compiled circuit $\tilde{C}$
is also a $2^n \times 2^n$ unitary matrix. This matrix can be formed
by the product of $2^n \times 2^n$ matrices $G_i$ which are a tensor
product of gate matrices from our basis. In fact, the $G_i$'s are the timesteps from
our \textsf{2D CCNTCM} model defined in Section \ref{subsec:models}, and
are formed from the tensor product of all single-qubit and two-qubit gates
which execute concurrently on disjoint qubits. Our desired target matrix $C$
is itself
a matrix from $U(2^n)$, and therefore we will need a distance metric
that operates on matrices (specifically, the difference of matrices).

\begin{equation}
\mathcal{C} = G_{D}G_{D-1}\cdots G_{2} G_{1}
\end{equation}

One distance metric used in theoretical literature
is the operator norm of a matrix $M$,
is defined as the maximum amount it scales the vector norm
of all unit-length vectors. This is sometimes also called the
infinity-norm, or supremum-norm (sup-norm).

\begin{equation}
\| M \|_{\infty} = \max_{\| \ket{v} \| = 1} \| M \ket{v} \|
\end{equation}

However, this is not an operational definition.
Moreover, we often wish to neglect a global phase in a unitary matrix,
which is not measurable in quantum physics. This is equivalent to
defining the set of valid $n$-qubit quantum gates as the
group $SU(2^n) = U(2^n) / U(1)$. To measure phase-independent
distance between two unitary matrices, we can use the following
distance measure due to Fowler \cite{Fowler2011}.

\begin{equation}
dist(U, V) = \| U - V\| \equiv \sqrt{\frac{2^n - |tr(U^{\dag}V)|}{2^n}}
\end{equation}

Now can quantify the quality of our approximations through an
error $\epsilon$.

\begin{equation}
\| C - \tilde{C}\| = \| C -  G_D\cdots G_1 \| < \epsilon
\end{equation}

Often $\epsilon$ will be small, and we will upper bound it by some
power of $\frac{1}{2}$. Therefore, we define a
new parameter which is the number of bits needed to encode the exponent
of this increasingly small fraction.

\begin{equation}
\epsilon = \frac{1}{2^n} \qquad
n = \log(1/\epsilon)
\end{equation}

It is natural to suppose that compiling better approximations requires
more resources, and these resources are expressed as functions of these
parameters $\epsilon$ and $n$.\footnote{This is not the same as our circuit
width $n$, and we will distinguish between the two when there is ambiguity.}
In fact, often the efficiency and the
capabilities of a quantum
compiler depend on its basis. Therefore, we conclude this section by
discussing circuit bases.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Circuit Bases}
\label{subsec:qcompile-bases}

\begin{definition}{\textbf{Circuit basis.}}
A basis for a quantum circuit is a universal set of
bounded-qubit (usually $3$-qubit) gates.
We call a basis \emph{finite} if it contains a finite
number of gates; that is, it contains discrete gates and not an infinite
continuum of gates. We call a basis \emph{fixed} if its members are independent
of any input size.
\end{definition}

For fault-tolerant quantum computing, we are interested in compiling
circuits to a fixed, finite basis. What does it mean for a fixed, finite
basis to be universal for an infinite group like $SU(2^n)$?

\begin{definition}{\textbf{Universal approximation.}}
We call a fixed, finite set of gates $\mathcal{G}$ \emph{universal} for
a group $G$ iff for every desired target $C \in G$ and
desired error $\epsilon$, we can return a
sequence of gates $(g_1,g_2,\ldots,g_S)$ from $\mathcal{G}$ where

\begin{equation}
\| C - g_1 g_2 \cdots g_S \| \le \epsilon
\end{equation}

\end{definition}

This defines whether a gateset is a basis, or whether universal approximation
is even possible (non-constructively). We will see in later sections that
quantum compilers are concerned with constructive approaches to
\emph{efficiently} return such a compiled sequence $\tilde{C} = \prod g_i$

What gatesets are known to be fixed, finite, and universal, and therefore
suitable bases for quantum compilation?

We recall one such basis from our definition of \textsf{2D CCNTCM} in
Section \ref{subsec:models}, with the exception of the non-unitary operation
$MeasureZ$. However, $MeasureZ$ is implicitly assumed as part of any basis,
and is the means by which we can offload postprocessing to a classical
controller.

\begin{equation}
\mathcal{G}'' = \{X, Z, H, Toffoli, CNOT\}
\end{equation}

It is important to note that the only non-Clifford gate in the above basis
is $Toffoli$.
The Clifford group $\mathcal{C}_n$ by itself is \emph{not}
universal.
This is unfortunate given that many quantum error-correcting codes have
efficient implementations \emph{only} for Clifford gates. In fact, it is provable
that \emph{any} universal gateset must possess at least one
non-Clifford gate \cite{Zeng2011}.

Two popular choices for the non-Clifford gate in a basis are the $T = R_Z(\pi/4)$
gate and the $Toffoli = \Lambda^2(X)$ gate. Since these are not ``natively''
supported (non-transveral) in many codes, they must often be implemented
probabilistically using only Clifford operations and $MeasureZ$, usually
by way of a so-called ``magic'' state.
Therefore, many quantum compilers
use the Clifford+$T$ basis $\mathcal{C}_2 \cup \{ T \}$ or the Clifford+$Toffoli$ basis $\mathcal{C}_2 \cup \{ Toffoli \}$, and measure
the non-Clifford gate as the most expensive resource. It is an area of
active research
whether $T$ or $Toffoli$ is more efficient to implement
\cite{Jones2013a,Eastin2012}.

For single-qubit compilation, the $\{H,T, T^{\dagger}\}$ gateset is universal and
plays an important role in the literature. Other compilers may add
the Clifford gates $S$ and $S^{\dagger}$ to the basis $\mathcal{G}'$ above,
but this does not change its universality nor its asymptotic efficiency for
compiling.

We are now prepared to discuss resources for measuring the efficiency of
a quantum compiler.