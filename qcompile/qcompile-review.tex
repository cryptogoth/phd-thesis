\section{Quantum Compiler Review}
\label{sec:qcompile-review}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Quantum Compiling Before 2012}
\label{subsec:qcompiile-pre2012}

The first known quantum compiling result by Lloyd showed that almost any two
distinct single-qubit gates were universal for single-qubit compiling
\cite{Lloyd1995}. However, the runtime and length of a compiled sequence of gates
could take exponentially long in the desired error precision: $O(1/\epsilon)$
The first \emph{efficient} quantum compiler due to
Solovay-Kitaev (SK) as implemented by Dawson-Nielsen had an original depth overhead
of $O(\log^{2.71}(1/\epsilon))$ and classical
running time of $O(\log^{3.97}(1/\epsilon))$. This is a seminal result in
the field of quantum computation, and as such it was reviewed in the previous
section (\ref{sec:qcompile-sk}). We will abbreviate it afterwards as SK-DN.
It was later improved by Kitaev-Shen-Vyalyi
to have a longer running time but smaller depth overhead of $O(\log^{3+o(1)}(n/\epsilon))$
\cite{Kitaev2002}, an algorithm we will call SK-KSV.
This improvement was achieved by repeated rounds of sparsifying and
telescoping finer nets based on coarser nets. Both SK-DN and SK-KSV can be
generalized to $n$-qubit compiling, but in the latter case the multiplicative
prefactor has a doubly exponentially dependence of $exp(2^n)$. Suggestions
for improving this to be $poly(2^n)$ are provided in the text, but this remains
an interesting open problem.

In the same text, a more parallel compiling procedure was discovered by Kitaev-Shen-
Vyalyi with a depth overhead of $O(\log n + \log\log(1/\epsilon))$ but
with a width of $O(n^3)$ on $\textsc{AC}$ \cite{Kitaev2002}.

This involves the generation of an $n$-qubit quantum Fourier state into a register
and the controlled-addition
modulo $2^n$ into this register. The first step is done using phase estimation
and an approximative inverse QFT using classical post-processing.
This controlled-addition step is known as
\emph{phase kickback} in recent literature \cite{Jones2012}. Therefore, we
refer to this algorithm as PK-KSV.
Moreover, the KSV procedure relies on a prior decomposition into
single-qubit gates.
a unitary matrix in $SU(N=2^n)$ into (controlled) single-qubit gates,
An equivalent, alternative proof is given by Cleve-Watrous \cite{Cleve2000}.

%Numerical comparisons between SK and KSV can be found in Section \ref{sec:ksv-results}.

As early as 2004, Austin Fowler pioneered the use of optimized enumeration
of gate sequences over a single-qubit basis, using efficient data structures
and heuristics to de-dupe (remove duplicates) a database of optimal, unique
sequences up to
a certain length \cite{Fowler2011}. He used the basis $\mathcal{C}_1 \cup \{ T, T^{\dagger} \}$
and gave efficient, fault-tolerant implementations of this basis in the
Steane code. Due to the fact that the Clifford group is closed under
matrix multiplication, every compiled Fowler sequence can be simplified as a
Clifford gate alternating with $T$. Asymptotically, this still runs in time
$|\mathcal{B}|^\ell$ to produce compiled sequences of optimal length $\ell$.
It is a single-qubit, exact-synthesis


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Quantum Compiling in 2012 and After}
\label{subsec:qcompiile-post2012}

This may be optimized using classical parallelization and hardware acceleration
\cite{Booth2012}, possibly also for scaling this approach to
two-qubit compilation with $\mathcal{C}_2$ (containing 11,520
elements).

Matsumoto-Amano

Bocharov-Svore

Kliuchnikov 1,2,3

VanMeter, Horseman

Selinger

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Magic States for Quantum Compiling}

Instead of using non-Clifford gates to complete our basis into a universal
gate set, we can include ``non-Clifford'' states as an additional resource.
These states are called \emph{magic states} if, combined with the Clifford
gates, enable universal quantum computation.
Quantum compilers which use these magic states count them as a non-Clifford
resource instead of $T$ or Toffoli gates, since such states cannot
be produced directly using Clifford gates. Rather, they must be
distilled in a probabilistic procedure which itself uses only 
Clifford gates and measurement.

There are two types of magic states, 
The most famous such example is the $+1$ eigenstate of the Hadamard operator,
often written as:

% TODO Fact check this, what about \ket{0} + e^{i\pi/4}\ket{1}
\begin{equation}
\ket{H} = \cos(\pi/8)\ket{0} + \sin(\pi/8)\ket{1}
\end{equation}

Magic state distillation was originally proposed by Bravyi and Kitaev
\cite{Bravyi2005} as a model of universal quantum computation (UQC) which
allowed for noisy, or imperfectly prepared, initial quantum states. These
noisy states could be ``purified'' or distilled down to certain states
that are ``magic'' in that, combined with the Clifford gates, they enable
UQC. These magic states come in two types, the eigenstates
of the $H$ or another operator, which we call $A$.

\begin{equation}
H = 
\normtwo
\left[ \begin{array}{cc}
1 & 1\\
1 & -1
\end{array} \right]
\qquad
A = e^{i\pi / 4} SH = \frac{e^{i\pi/4}}{\sqrt{2}}
\left[ \begin{array}{cc}
1 & 1\\
i & -i
\end{array} \right]
\label{eqn:T}
\end{equation}

The noisy initial states can be considered to be prepared
These states are distilled via successive rounds of recursive error
correction, where the efficiency of distillation with each round,
and the resources required to do so, depend on the code used.

% TODO Insert here a comparison of different codes used
% Original Knill result
% Bravyi-Kitaev
% Bravyi-Haah

\subsection{Alternative Bases and Resources}
\label{subsec:alt-resources}

Now we turn to three recent works which use magic state distillation to compile
arbitrary single-qubit gates. These works either compile to an alternate
basis from $\mathcal{C}_n \cup \{T,T^{\dagger}\}$.

A recent approach by Bocharov-Gurevich-Svore \cite{Bocharov2013}
compiles to subsets of the Clifford group augmented with the non-Clifford
$V$-basis, which was proven to permit the lower-bound of compiled sequence length
$O(\log^1(1/\epsilon)$
\cite{Harrow2003}.

\begin{equation}
V_1 = TODO \qquad V_2 = TODO \qquad V_3 = TODO
\end{equation}

This work uses the properties of Lipschitz quaternions with norms $5^l$, ($l \in \mathbb{Z}, l \ge 0$). It
contains a randomized algorithm whose running time is based on a conjecture from geometric number theory.
There is currently no complete, fault-tolerant method of compiling all three gates from the $V$ basis into
our usual universal set of $\mathcal{C}_1 \cup \{T\}$. However, the appendix of \cite{Bocharov2013}
gives a method for implementing the exact $V_2$ gate using the (probabilistic) magic state distillation of
Duclos-Cianci and Svore \cite{DuclosCianci2012}. The average cost in $\ket{H}$
states for enacting a $V_2$ gate is $22.75$. It is an open problem how many
$\ket{H}$ states are needed to enact the gates $V_1$ and $V_3$.
We cannot compare it directly to previous algorithms which consider the number of $T$ gates ($T_c$)
the primary resource, or the compiled sequence length $D'$ as an upper bound to $T_c$.
However, the SK algorithm allows us to provide an alternate basis. By
comparing the compiled sequence lengths in the $V$ basis and noting any
improvements over the $\mathcal{C}_1 \cup \{T\}$ basis, 
measuring the length of compiled sequences 

The previous works all assume a minimal basis which only includes a fixed
number (usually one) non-Clifford gate (a $T$ gate or Toffoli). We can
call these ``reduced instruction set computing'' (RISC) bases, in analogy to
digital processor architectures.
In contrast, Landahl and
Cesare consider a ``complex instruction set computing'' (CISC) basis which
includes 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Generalizations to Quantum Compiling}
\label{subsec:alt-tasks}

The literature of quantum compiling has traditionally drawn boundaries
around itself, restricting its study to approximation of unitary gates
with perfect operations. However, s
around 