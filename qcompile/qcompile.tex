\chapter{Quantum Compiling}
\label{chap:qcompile}

Quantum compiling is the approximation of an $n$-qubit
unitary operation, determined by a high-level algorithm,
using a fixed, finite, universal set
of fault-tolerant gates. Like quantum architecture, quantum
compiling plays an intermediate role between theory and experiment.
Quantum compiling helps mitigate one source of error,
the difference $\epsilon$ between a desired gate and its
finite approximation,
and consumes its own circuit resources as a function of
$(1 / \epsilon)$.

In a larger context, efficient quantum 
compiling ensures we don't lose any super-polynomial speedups
while implementing a quantum algorithm such as Shor's algorithm.
In this dissertation, we are particularly interested in
quantum compiling as a means of completing the
factoring architecture in Chapter \ref{chap:factor-sublog}.
Most interestingly, quantum compiling itself
is an algorithm and can be mapped to a hybrid nearest-neighbor
architecture with low depth. That is the subject of this chapter:
we combine a general pedagogical review of quantum compiling,
we describe a particular low-depth approach called phase kickback,
and then we present our main results: optimizing phase kickback
to \textsf{2D CCNTCM} and applying it to sub-logarithmic factoring.

In Section \ref{sec:qcompile-bg}, we notation and circuit resources,
building upon the primer on circuit bases in Section \ref{sec:intro-basis}.
We also discuss
variations and subtasks of quantum compiling that are cross-cutting themes
in the literature as well as their inter-relationships. This
provides a framework to understand the next two sections, which
survey existing related works.

In Section \ref{sec:qcompile-sk}, we review the foundational
result in this field, the Solovay-Kitaev algorithm, and how it
continues to shape quantum compiler research. We also discuss
lower bounds on any SK-style approach to quantum compiling.
Building upon this,
in Section \ref{sec:qcompile-review}, we review the large
amount of recent literature on single-qubit quantum compiling,
almost all of which has a logarithmic depth lower bound.
We then provide an
at-a-glance resource comparison of all known single-qubit quantum compiling methods
to date in Section \ref{sec:qcompile-compare}.

We then turn to the lowest-depth alternative to
the single-qubit quantum compilers discussed previously
in Section \ref{sec:qcompile-qfs}. This new approach
trades increased width for low depth by combining \emph{phase kickback}
with a quantum Fourier state.

In Section \ref{sec:qcompile-ksv}, we contribute an improved
algorithm for generating quantum Fourier states based on
Kitaev-Shen-Vyalyi \cite{Kitaev2002}. We also calculate the
parameters necessary for any practical implementation as well as
the particular circuit resources consumed on \textsf{2D CCNTCM}.
We then compare the KSV approach to a recent alternative
by Jones which distills quantum Fourier states recursively \cite{Jones2013}.
Finally, in Section \ref{sec:qcompile-maj}, we contribute the
missing piece from our sub-logarithmic factoring architecture
from Chapter \ref{chap:factor-sublog}: single-qubit rotations
compiled in sub-logarithmic depth.

These last two sections represent the main contributions of this chapter.

%Finally, in Section \ref{sec:qcompile-conclude}, we conclude by summarizing
%the overall themes of quantum compiling and presenting interesting
%directions for future research.

\input{qcompile/qcompile-bg.tex}

\input{qcompile/qcompile-sk.tex}

\input{qcompile/qcompile-review.tex}

\input{qcompile/qcompile-compare.tex}

\input{qcompile/qcompile-qfs.tex}

\input{qcompile/qcompile-ksv.tex}

\input{qcompile/qcompile-maj.tex}

\input{qcompile/qcompile-conclude.tex}