\section{Introduction}
\label{sec:fpl-intro}

Shor's factoring algorithm is a central result in quantum computing, with an
exponential speed-up over the best known classical algorithm \cite{Shor1994}.
As the most notable example of a quantum-classical complexity separation, much
effort has been devoted to implementations of factoring on a
realistic architectural model of a quantum computer
\cite{Beauregard2002,Kutin2006,VanMeter2006,VanMeter2005,VanMeterIL2005}.
We can bridge the gap between
the theoretical algorithm and a physical implementation by describing
the layout and interactions of qubits at an intermediate,
architectural level of abstraction.
This gives us a model for measuring circuit resources and their tradeoffs.
In this work, we present a circuit implementation for prime
factorization of an $n$-bit integer
on a two-dimensional architecture that allows concurrent (parallel) two-qubit operations
between neighboring qubits, an omnipresent classical controller, and
modules which are allowed to teleport qubits to each other. We call this new
model \textsc{\textsf{2D CCNTCM}}.
We show that our circuit construction is asymptotically more efficient in circuit depth than previous state-of-the-art techniques for nearest-neighbor
architectures, achieving a depth of $O(\log^3 n)$, a size of
$O(n^4\log n)$, and a width of $O(n^4)$ qubits, as detailed in Table
\ref{tab:fpl-results} of Section \ref{sec:fpl-results}.

Our technique hinges on several key building blocks.
Section \ref{sec:fpl-bg} introduces quantum architectural models, circuit
resources, and constant-depth communication techniques due to
\cite{Harrow2012,Rosenbaum2012}.
Section \ref{sec:fpl-related} places our work in the context of existing
results.
In Section \ref{sec:csa}, we provide a self-contained pedagogical review
of the carry-save technique and encoding.
In Section \ref{sec:csa-mod-add} we modify and extend the carry-save technique to a 2D
modular adder,
which we then use as a basis for a modular multiplier
(Section \ref{sec:csa-mod-mult}) and a modular exponentiator
(Section \ref{sec:modexp}).
For each building block, we provide numerical upper bounds for the
required circuit resources.
Finally, we compare our asymptotic circuit resource usage
with other factoring implementations.
